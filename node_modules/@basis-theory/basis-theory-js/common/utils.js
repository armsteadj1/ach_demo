"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformTokenResponseCamelCase = exports.transformTokenRequestSnakeCase = exports.transformResponseCamelCase = exports.transformRequestSnakeCase = exports.transformReactorResponseCamelCase = exports.transformReactorRequestSnakeCase = exports.transformAtomicResponseCamelCase = exports.transformAtomicRequestSnakeCase = exports.transformAtomicReactionRequestSnakeCase = exports.proxyRawResponse = exports.getQueryParams = exports.errorInterceptor = exports.dataExtractor = exports.createRequestConfig = exports.concatResponseTransformermWithDefault = exports.concatRequestTransformerWithDefault = exports.assertInit = void 0;

var _axios = _interopRequireDefault(require("axios"));

var _camelcaseKeys = _interopRequireDefault(require("camelcase-keys"));

var _snakeCase = require("snake-case");

var _snakecaseKeys = _interopRequireDefault(require("snakecase-keys"));

var _BasisTheoryApiError = require("./BasisTheoryApiError");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const assertInit = prop => {
  // eslint-disable-next-line unicorn/no-null
  if (prop === null || prop === undefined) {
    throw new Error('BasisTheory has not yet been properly initialized.');
  }

  return prop;
};

exports.assertInit = assertInit;

const transformRequestSnakeCase = data => {
  if (typeof data === 'undefined') {
    return undefined;
  }

  return (0, _snakecaseKeys.default)(data, {
    deep: true
  });
};

exports.transformRequestSnakeCase = transformRequestSnakeCase;

const proxyRawResponse = data => data;

exports.proxyRawResponse = proxyRawResponse;

const transformReactorRequestSnakeCase = reactor => {
  if (typeof reactor === 'undefined') {
    return undefined;
  }

  return { ...(0, _snakecaseKeys.default)(reactor, {
      deep: true
    }),
    ...(reactor.configuration !== undefined ? {
      configuration: reactor.configuration
    } : {})
  };
};

exports.transformReactorRequestSnakeCase = transformReactorRequestSnakeCase;

const transformAtomicRequestSnakeCase = data => {
  if (typeof data === 'undefined') {
    return undefined;
  }

  return { ...(0, _snakecaseKeys.default)(data, {
      deep: true
    }),
    ...(data.metadata !== undefined ? {
      metadata: data.metadata
    } : {})
  };
};

exports.transformAtomicRequestSnakeCase = transformAtomicRequestSnakeCase;

const transformTokenRequestSnakeCase = token => {
  if (typeof token === 'undefined') {
    return undefined;
  }

  return { ...(0, _snakecaseKeys.default)(token, {
      deep: true
    }),
    ...(token.data !== undefined ? {
      data: token.data
    } : {}),
    ...(token.metadata !== undefined ? {
      metadata: token.metadata
    } : {})
  };
};

exports.transformTokenRequestSnakeCase = transformTokenRequestSnakeCase;

const transformAtomicReactionRequestSnakeCase = request => {
  if (typeof request === 'undefined') {
    return undefined;
  }

  return { ...(0, _snakecaseKeys.default)(request, {
      deep: true
    }),
    ...(request.requestParameters !== undefined ? // eslint-disable-next-line camelcase
    {
      request_parameters: request.requestParameters
    } : {})
  };
};

exports.transformAtomicReactionRequestSnakeCase = transformAtomicReactionRequestSnakeCase;

const transformTokenResponseCamelCase = token => {
  if (typeof token === 'undefined') {
    return undefined;
  }

  return { ...(0, _camelcaseKeys.default)(token, {
      deep: true
    }),
    ...(token.data !== undefined ? {
      data: token.data
    } : {}),
    ...(token.metadata !== undefined ? {
      metadata: token.metadata
    } : {})
  };
};

exports.transformTokenResponseCamelCase = transformTokenResponseCamelCase;

const transformReactorResponseCamelCase = reactor => {
  if (typeof reactor === 'undefined') {
    return undefined;
  }

  return { ...(0, _camelcaseKeys.default)(reactor, {
      deep: true
    }),
    ...(reactor.configuration !== undefined ? {
      configuration: reactor.configuration
    } : {})
  };
};

exports.transformReactorResponseCamelCase = transformReactorResponseCamelCase;

const transformResponseCamelCase = data => {
  if (typeof data === 'undefined') {
    return undefined;
  }

  return (0, _camelcaseKeys.default)(data, {
    deep: true
  });
};

exports.transformResponseCamelCase = transformResponseCamelCase;

const transformAtomicResponseCamelCase = data => {
  if (typeof data === 'undefined') {
    return undefined;
  }

  return { ...(0, _camelcaseKeys.default)(data, {
      deep: true
    }),
    ...(data.metadata !== undefined ? {
      metadata: data.metadata
    } : {})
  };
};

exports.transformAtomicResponseCamelCase = transformAtomicResponseCamelCase;

const dataExtractor = res => res === null || res === void 0 ? void 0 : res.data;

exports.dataExtractor = dataExtractor;

const concatRequestTransformerWithDefault = requestTransformer => [...[], ...[requestTransformer], ..._axios.default.defaults.transformRequest];

exports.concatRequestTransformerWithDefault = concatRequestTransformerWithDefault;

const concatResponseTransformermWithDefault = responseTransformer => [..._axios.default.defaults.transformResponse, ...[responseTransformer]];

exports.concatResponseTransformermWithDefault = concatResponseTransformermWithDefault;

const createRequestConfig = (options, transformers) => {
  if (!options) {
    if (!transformers) {
      return undefined;
    }

    return { ...(transformers.transformRequest !== undefined ? {
        transformRequest: concatRequestTransformerWithDefault(transformers.transformRequest)
      } : {}),
      ...(transformers.transformResponse !== undefined ? {
        transformResponse: concatResponseTransformermWithDefault(transformers.transformResponse)
      } : {})
    };
  }

  const {
    apiKey,
    correlationId
  } = options;
  const apiKeyHeader = apiKey ? {
    [_constants.API_KEY_HEADER]: apiKey
  } : {};
  const correlationIdHeader = correlationId ? {
    [_constants.BT_TRACE_ID_HEADER]: correlationId
  } : {};
  return {
    headers: { ...apiKeyHeader,
      ...correlationIdHeader
    },
    ...((transformers === null || transformers === void 0 ? void 0 : transformers.transformRequest) !== undefined ? {
      transformRequest: concatRequestTransformerWithDefault(transformers.transformRequest)
    } : {}),
    ...((transformers === null || transformers === void 0 ? void 0 : transformers.transformResponse) !== undefined ? {
      transformResponse: concatResponseTransformermWithDefault(transformers.transformResponse)
    } : {})
  };
}; // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/explicit-module-boundary-types


exports.createRequestConfig = createRequestConfig;

const errorInterceptor = error => {
  var _error$response, _error$response2;

  const status = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) || -1;
  const data = (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.data;
  throw new _BasisTheoryApiError.BasisTheoryApiError(error.message, status, data);
};

exports.errorInterceptor = errorInterceptor;

const getQueryParams = query => {
  const keys = Object.keys(query);

  if (keys.length) {
    const params = new URLSearchParams();

    const appendSafe = (key, value) => {
      const type = typeof value; // eslint-disable-next-line unicorn/no-null

      if (value === null || ['boolean', 'number', 'string'].includes(type)) {
        params.append((0, _snakeCase.snakeCase)(key), value);
      }
    };

    keys.forEach(key => {
      const value = query[key];

      if (Array.isArray(value)) {
        value.forEach(aValue => {
          appendSafe(String(key), aValue);
        });
      } else {
        appendSafe(String(key), value);
      }
    });
    return `?${params.toString()}`;
  }

  return '';
};

exports.getQueryParams = getQueryParams;