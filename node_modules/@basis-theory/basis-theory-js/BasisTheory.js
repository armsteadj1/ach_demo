"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BasisTheory = void 0;

var _applications = require("./applications");

var _atomic = require("./atomic");

var _banks = require("./atomic/banks");

var _cards = require("./atomic/cards");

var _common = require("./common");

var _constants = require("./common/constants");

var _BasisTheoryEncryptionAdapters = require("./encryption/BasisTheoryEncryptionAdapters");

var _logs = require("./logs");

var _permissions = require("./permissions");

var _reactorFormulas = require("./reactor-formulas");

var _reactors = require("./reactors");

var _tenants = require("./tenants");

var _tokens = require("./tokens");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const defaultInitOptions = {
  apiBaseUrl: _constants.DEFAULT_BASE_URL,
  elements: false,
  elementsBaseUrl: _constants.DEFAULT_ELEMENTS_BASE_URL
};

class BasisTheory {
  constructor() {
    _defineProperty(this, "_initStatus", 'not-started');
  }

  async init(apiKey, options = {}) {
    if (this._initStatus !== 'not-started' && this._initStatus !== 'error') {
      throw new Error('This BasisTheory instance has been already initialized.');
    }

    this._initStatus = 'in-progress';

    try {
      this._initOptions = Object.freeze({ ...defaultInitOptions,
        ...options
      });
      let baseUrl = this._initOptions.apiBaseUrl;

      try {
        const baseUrlObject = new URL(this.initOptions.apiBaseUrl);

        if (baseUrlObject.hostname === 'localhost') {
          baseUrlObject.protocol = 'http';
        } else {
          baseUrlObject.protocol = 'https';
        }

        baseUrl = baseUrlObject.toString().replace(/\/$/u, '');
      } catch {
        throw new Error('Invalid format for the given API base url.');
      }

      this._tokens = new _tokens.BasisTheoryTokens({
        apiKey,
        baseURL: new URL(_constants.CLIENT_BASE_PATHS.tokens, baseUrl).toString()
      });
      this._atomic = new _atomic.BasisTheoryAtomic({
        apiKey,
        baseURL: new URL(_constants.CLIENT_BASE_PATHS.atomic, baseUrl).toString()
      });
      this._applications = new _applications.BasisTheoryApplications({
        apiKey,
        baseURL: new URL(_constants.CLIENT_BASE_PATHS.applications, baseUrl).toString()
      });
      this._tenants = new _tenants.BasisTheoryTenants({
        apiKey,
        baseURL: new URL(_constants.CLIENT_BASE_PATHS.tenants, baseUrl).toString()
      });
      this._logs = new _logs.BasisTheoryLogs({
        apiKey,
        baseURL: new URL(_constants.CLIENT_BASE_PATHS.logs, baseUrl).toString()
      });
      this._reactorFormulas = new _reactorFormulas.BasisTheoryReactorFormulas({
        apiKey,
        baseURL: new URL(_constants.CLIENT_BASE_PATHS.reactorFormulas, baseUrl).toString()
      });
      this._reactors = new _reactors.BasisTheoryReactors({
        apiKey,
        baseURL: new URL(_constants.CLIENT_BASE_PATHS.reactors, baseUrl).toString()
      });
      this._atomicBanks = new _banks.BasisTheoryAtomicBanks({
        apiKey,
        baseURL: new URL(_constants.CLIENT_BASE_PATHS.atomicBanks, baseUrl).toString()
      });
      this._atomicCards = new _cards.BasisTheoryAtomicCards({
        apiKey,
        baseURL: new URL(_constants.CLIENT_BASE_PATHS.atomicCards, baseUrl).toString()
      });
      this._permissions = new _permissions.BasisTheoryPermissions({
        apiKey,
        baseURL: new URL(_constants.CLIENT_BASE_PATHS.permissions, baseUrl).toString()
      });
      this._encryption = new _BasisTheoryEncryptionAdapters.BasisTheoryEncryptionAdapters();

      if (this._initOptions.elements) {
        await this.loadElements(apiKey);
      }

      this._initStatus = 'done';
    } catch (error) {
      this._initStatus = 'error';
      throw error;
    }

    return this;
  }

  async loadElements(apiKey) {
    let elementsBaseUrl;

    try {
      elementsBaseUrl = new URL(this.initOptions.elementsBaseUrl);
    } catch {
      throw new Error('Invalid format for the given Elements base url.');
    }

    const elements = await (0, _common.loadElements)();
    await elements.init(apiKey, elementsBaseUrl.toString().replace(/\/$/u, ''));
    this.elements = elements;
  } // these should be set by the init call only.

  /* eslint-disable accessor-pairs */


  get initOptions() {
    return (0, _common.assertInit)(this._initOptions);
  }

  get tokens() {
    return (0, _common.assertInit)(this._tokens);
  }

  get atomic() {
    return (0, _common.assertInit)(this._atomic);
  }

  get encryption() {
    return (0, _common.assertInit)(this._encryption);
  }

  get applications() {
    return (0, _common.assertInit)(this._applications);
  }

  get tenants() {
    return (0, _common.assertInit)(this._tenants);
  }

  get logs() {
    return (0, _common.assertInit)(this._logs);
  }

  get reactorFormulas() {
    return (0, _common.assertInit)(this._reactorFormulas);
  }

  get reactors() {
    return (0, _common.assertInit)(this._reactors);
  }

  get atomicBanks() {
    return (0, _common.assertInit)(this._atomicBanks);
  }

  get atomicCards() {
    return (0, _common.assertInit)(this._atomicCards);
  }

  get permissions() {
    return (0, _common.assertInit)(this._permissions);
  }
  /* eslint-enable accessor-pairs */


  get elements() {
    return (0, _common.assertInit)(this._elements);
  }

  set elements(elements) {
    this._elements = elements;
  }

}

exports.BasisTheory = BasisTheory;