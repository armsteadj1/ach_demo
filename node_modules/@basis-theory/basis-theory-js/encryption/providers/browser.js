"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.browserAdapter = void 0;

var _utils = require("./utils");

let signAlgorithm;
let algorithm;

const init = browserEncryption => {
  var _browserEncryption$op, _browserEncryption$op2, _browserEncryption$al;

  signAlgorithm = {
    name: 'RSA-OAEP',
    modulusLength: (_browserEncryption$op = browserEncryption === null || browserEncryption === void 0 ? void 0 : (_browserEncryption$op2 = browserEncryption.options) === null || _browserEncryption$op2 === void 0 ? void 0 : _browserEncryption$op2.defaultKeySize) !== null && _browserEncryption$op !== void 0 ? _browserEncryption$op : 4096,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: 'SHA-256'
  };
  algorithm = (_browserEncryption$al = browserEncryption === null || browserEncryption === void 0 ? void 0 : browserEncryption.algorithm) !== null && _browserEncryption$al !== void 0 ? _browserEncryption$al : 'RSA';
};

const convertBinaryToPem = (binaryData, label) => {
  const base64Cert = (0, _utils.arrayBufferToBase64String)(binaryData);
  let pemCert = `-----BEGIN ${label} KEY-----\r\n`;
  let nextIndex = 0;

  while (nextIndex < base64Cert.length) {
    pemCert += nextIndex + 64 <= base64Cert.length ? `${base64Cert.slice(nextIndex, nextIndex + 64)}\r\n` : `${base64Cert.slice(nextIndex)}\r\n`;
    nextIndex += 64;
  }

  pemCert += `-----END ${label} KEY-----\r\n`;
  return pemCert;
};

const convertPemToBinary = (pem, label) => {
  const lines = pem.split('\n');
  let encoded = '';

  for (const line of lines) {
    if (line.trim().length > 0 && !line.includes(`-BEGIN ${label} KEY-`) && !line.includes(`-END ${label} KEY-`)) {
      encoded = encoded + line.trim();
    }
  }

  return (0, _utils.base64StringToArrayBuffer)(encoded);
};

const generateRSAKeys = async () => {
  const keyPair = await window.crypto.subtle.generateKey(signAlgorithm, true, ['encrypt', 'decrypt']);
  const exportedPublic = await window.crypto.subtle.exportKey('spki', keyPair.publicKey);
  const exportedPrivate = await window.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
  return {
    publicKey: convertBinaryToPem(exportedPublic, 'PUBLIC'),
    privateKey: convertBinaryToPem(exportedPrivate, 'PRIVATE')
  };
};

const generateKeyMap = {
  RSA: generateRSAKeys,
  AES: () => Promise.reject()
};

const generateKeys = () => generateKeyMap[algorithm]();

const loadPublicKey = pem => window.crypto.subtle.importKey('spki', convertPemToBinary(pem, 'PUBLIC'), signAlgorithm, true, ['encrypt']);

const loadPrivateKey = pem => window.crypto.subtle.importKey('pkcs8', convertPemToBinary(pem, 'PRIVATE'), signAlgorithm, true, ['decrypt']);

const encrypt = async (publicKey, data) => {
  const key = await loadPublicKey(publicKey);
  const encrypted = await window.crypto.subtle.encrypt({
    name: signAlgorithm.name
  }, key, // eslint-disable-next-line node/no-unsupported-features/node-builtins
  new TextEncoder().encode(data).buffer);
  return (0, _utils.arrayBufferToBase64String)(encrypted);
};

const decrypt = async (privateKey, data) => {
  const key = await loadPrivateKey(privateKey);
  const decrypted = await window.crypto.subtle.decrypt({
    name: signAlgorithm.name
  }, key, (0, _utils.base64StringToArrayBuffer)(data)); // eslint-disable-next-line node/no-unsupported-features/node-builtins

  return new TextDecoder().decode(decrypted);
};

const browserAdapter = {
  name: 'browser',
  generateKeys,
  init,
  encrypt,
  decrypt
};
exports.browserAdapter = browserAdapter;