"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeAdapter = void 0;

var _crypto = require("crypto");

let keySize;
let algorithm;

const init = nodeEncryption => {
  var _nodeEncryption$optio, _nodeEncryption$optio2, _nodeEncryption$algor;

  keySize = (_nodeEncryption$optio = nodeEncryption === null || nodeEncryption === void 0 ? void 0 : (_nodeEncryption$optio2 = nodeEncryption.options) === null || _nodeEncryption$optio2 === void 0 ? void 0 : _nodeEncryption$optio2.defaultKeySize) !== null && _nodeEncryption$optio !== void 0 ? _nodeEncryption$optio : 4096;
  algorithm = (_nodeEncryption$algor = nodeEncryption === null || nodeEncryption === void 0 ? void 0 : nodeEncryption.algorithm) !== null && _nodeEncryption$algor !== void 0 ? _nodeEncryption$algor : 'RSA';
};

const generateRSAKeys = () => {
  const {
    publicKey,
    privateKey
  } = (0, _crypto.generateKeyPairSync)('rsa', {
    modulusLength: keySize,
    publicKeyEncoding: {
      type: 'spki',
      format: 'pem'
    },
    privateKeyEncoding: {
      type: 'pkcs8',
      format: 'pem'
    }
  });
  return Promise.resolve({
    publicKey,
    privateKey
  });
};

const generateKeyMap = {
  RSA: generateRSAKeys,
  AES: () => Promise.reject()
};

const generateKeys = () => generateKeyMap[algorithm]();

const encrypt = (publicKey, data) => {
  const encrypted = (0, _crypto.publicEncrypt)({
    key: publicKey,
    padding: _crypto.constants.RSA_PKCS1_OAEP_PADDING,
    oaepHash: 'sha256'
  }, Buffer.from(data));
  return Promise.resolve(encrypted.toString('base64'));
};

const decrypt = (privateKey, data) => {
  const decrypted = (0, _crypto.privateDecrypt)({
    key: privateKey,
    padding: _crypto.constants.RSA_PKCS1_OAEP_PADDING,
    oaepHash: 'sha256'
  }, Buffer.from(data, 'base64'));
  return Promise.resolve(decrypted.toString());
};

const nodeAdapter = {
  name: 'node',
  generateKeys,
  init,
  encrypt,
  decrypt
};
exports.nodeAdapter = nodeAdapter;